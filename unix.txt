CH4 Files and Directories

The chdir() function only affects the working directory of the current process. <- 	will it	affect the cwd of the shell?

hard link : 不佔inode與disk space，
symbolic link : 建立獨立檔案，會佔用inode與disk space


Saved	set-user-ID	and	saved	set-group-ID
The	effecIve user ID and effecIve group	ID when a program is executed
If	a	program	P	owned	by	UserA	has	a	SUID	permission	
Any	one	who	executes	the	program	P	will	be	automaIcally	
setuid	to	UserA
Only root is able to set SUID/SGID permissions for a file

sticky bit
具有 sticky bit 屬性的該”目錄”下的檔案，其檔案或目錄只有檔案擁有者及 root 才有權力刪除或重新命名！ (such as /tmp)


superblock：記錄此 filesystem 的整體資訊，包括inode/block的總量、使用量、剩餘量， 以及檔案系統的格式與相關資訊等；
inode：記錄檔案的屬性，一個檔案佔用一個inode，同時記錄此檔案的資料所在的 block 號碼；
block：實際記錄檔案的內容，若檔案太大時，會佔用多個 block 。
Reference Counts :　The	number	of	pointers	that	points	to	an	i-node

 If	a	directory	is	empty,	but	a	process	has	opened	the	directory,	
it	is	removed	but	not	freed	
◦ No	new	file	can	be	created	in	the	to-be-removed	directory	
◦ It	is	freed	when	the	process	close	the	directory	<- Similar	to	unlink!

Every	process	has	a	current	working	directory	
◦ The	current	working	directory	is	inherited	from	the	parent	
◦ The	current	working	directory	for	each	process	is	independent	

p48 ?

The	/dev File System
Stores	device	special	files
• It	can	be	a	real	file	system	
– Each	device	special	file	is	created	with	the	mknod(1)
command	
• It	can	be	a	pseudo	file	system	
– Device	special	files	are	automaIcally	generated	when	a	device	
driver	is	registered


CH6 System Data Files and Information

modern UNIX	systems	move the encrypted password	into another secret	file, which	is only	readable by	system administrators  ( Linux: /etc/shadow)


CH7 Process Environment

atexit -> Register	up	to	32	customized	functions
– exit
	• Call	atexit registered	functions
	• Performed	a	clean	shutdown	of	the	standard	I/O	library 把文件緩衝區的內容寫回文件，就是"清理I/O緩衝"。
	• fclose()	all	streams,	remove	tmpfile()	
– _exit	and	_Exit
	• Terminate	immediately

• Delete	an	entry
	– This	is	simple,	just	free	a	string	and	move	all	subsequent	pointers	
down	one	
• Modify	an	entry
	– If	new-size ≥ old-size, just overwrite	the	old	one
	– If	new-size > old-size, allocate a	new	space the new variable and	make the pointer point	to	the	new	location
• Add	an	entry
	– Add	for	the	1st time,	allocate	a	new	space	for	the	entire	list
	– Add	for	non-1st time,	reallocate	a	larger	space	for	the	entire	list

P17 ?
Library injection?

sbrk(2)	system	call	
• This	system	call	expands	(or	contracts)	the	heap of	the	process	
– However,	most	versions	of	malloc	and	free	never	decrease	their	memory	size
– The	space	that	we	free	is	available	for	a	later	allocation
– The	freed	space	is	usually	kept	in	the	malloc	pool,	not	returned	to	the	kernel

Volatile variable store in memory

– No	optimization:	gcc places	everything	in	memory
– Full	optimization:	auto/register	variables	are	placed	in	registers


Ch8 Process Control

fork - The	parent	and	the	child	do	not	share	these	portions of memory,	but	they share	the	text	segment

terminal devices are line buffered
non-terminal devices are fully buffered

avoid zombie processes by calling fork twice.
The parent of second child is set to init while the first child is killed and init will reap the status.
利用Linux會在一個process的父行程結束時，自動把該行程的父行程變成init，也就是讓該process由init接管

When its parent	terminates,	init will be the new parent, which has a PID of 1

The	process	ID	does	not	change	across	an	exec,	because	a	new	process	is	not	created	


CH9 Process Relationship

Process Group
each process belongs to a process group
A	process	group	is	a	collection	of	one	or	more	processes – Usually	associated	with	the	same	job	
Each	process	group	can	have	a	process	group	leader	
– The	leader	is	identified	by	its	process	group	ID	being	equal	to	its	
process	ID
– A	group	leader	can	create	a	group,	create	processes	in	the	group,	and	
then	quit
– The	process	group	still	exists,	as	long	as	at	least	one	process	is	in	the	
group

• The	use	of	setpgid function
– It	is	called	after	a	fork	to	have	the	parent	set	the	process	group	ID	of	
the	child,	and
– Have	the	child	set	its	own	process	group	ID	
– The	above	two	actions	are	redundant,	but	they	guaranteed	that	the	
child	is	placed	into	its	own	process	group <- to	avoid	race	conditions

Sessions
A	session	is	a	collection	of	one	or	more	process	groups
pid_t setsid(void); <- Returns	pgid or	-1	if	the	caller	is	already	a	process	group	leader
If	the	calling	process	is	not	a	process	group	leader,	this function	creates	a	new	session
– The	process	becomes	the	session	leader	of	this	new	session
– The	process	is	the	only	process	in	this	new	session	
– The	process	becomes	the	process	group	leader	of	a	new	process	group.
– The	new	process	group	ID	is	the	process	ID	of	the	calling	process	
– The	process	has	no	controlling	terminal

When	a	user	logged	in,	the	session	leader	is	usually	the	shell

Controlling Terminal
A	session	can	have	a	single	controlling	terminal
The	session	leader	that	establishes	the	connection	to	the	 controlling	terminal	is	called	the	controlling	process	
The	process	groups	within	a	session	can	be	divided	into:
– A	single	foreground	process	group,	and
– One	or	more	background	process	groups	
If	a	session	has	a	controlling	terminal,
– It	has	a	single	foreground	process	group,	and
– All	other	process	groups	in	the	session	are	background	process	groups	

/dev/tty
– This	special	file	is	a	synonym	within	the	kernel	for	the	 controlling	terminal	
– If	the	program	doesn't	have	a	controlling	terminal,	the	open	of	this	device	will	fail

Job Control
This feature allows us to start multiple jobs from a single	terminal
Control	which	jobs	can	access	the	terminal	and	 which	jobs	are	to	run	in	the	background
• Job	control	requires	three	forms	of	support	
– A	shell	that	supports	job	control	
– The	terminal	driver	in	the	kernel	must	support	job	 control
– The	kernel	must	support	certain	job-control	signals

Definition	of	an	orphaned	process	group
– A	process	group	is	orphaned	if	the	parent	process	of	every	member	
is	either	a	member	of	the	group	or	not	a	member	of	the	group’s	session
– In	contrast,	a	process	group	is	not	orphaned	if	a	process	in	the	group	has	a	parent	
in	a	different	process	group	but	in	the	same session

P33 orphaned process group example
results:
• The	parent	and	the	child	prints	out	their	own	information
• The	parent	then	sleeps	for	5	seconds
• The	child	stopped	itself
• When	the	parent	terminates,	the	child	received	SIGHUP	and	SIGCONT
	– Since	the	child	has	assigned	the	SIGHUP	handler,	it	is	not	terminated
	– The	child	is	now	in	background,	so	read	from	TTY	got	the	EIO	error